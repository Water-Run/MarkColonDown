# 基本概念  

`Mark:down`是一个强大的`Markdown`预处理器. 作为`Markdown`的严格超集, 大幅扩展了`Markdown`的能力.  
`Mark:down`开源于[GitHub](https://github.com/Water-Run/MarkColonDown).
作为显式区分, 建议使用`.mcd`作为特有的后缀名. 不过, 你也可以使用其它后缀名--包括`.md`本身.  

## 能力概览  

`Mark:down`以`#:`("行指令", 也是项目名称的来源), 结合`{{}}`(代码内嵌)等语法, 为`Markdown`的编写实现了:  

1. **语法糖**. 将常用的 Markdown 结构压缩为简洁指令. `#:1` 到 `#:6` 对应各级标题, `#:!` 快速插入图片, `#:-` 和 `#:|` 以逗号分隔的方式构建表格, 等等. 每个指令都提供简化形式, 如 `#:image` 可写为 `#:!`, 在保持可读性的同时提升编写效率.

2. **预处理能力**. 通过 `#:include` 实现文件级别的模块化组织, 常将全局变量集中在 `Global.md` 中统一管理, 或将公共模板抽离为独立文件按需导入. `#:define` 提供编译期的查找替换, 配合 `Include_Base` 等编译指令设定的基路径, 构建起类似 C 语言头文件的依赖管理机制.

3. **控制流**. 使用 `#:if`/`#:elif`/`#:else` 根据表达式结果选择性输出内容, `#:for` 遍历数据结构批量生成段落, `#:while` 处理需要循环的场景. 结合 `#:<flag>` 语法可以根据编译时传入的标记(通过 `--flag` 参数)动态启用或禁用特定指令, 实现同一源码编译出不同版本文档的能力.

4. **内嵌代码**. 在 `#:code` 块中执行 `MiniScript` 脚本进行逻辑计算或调用外部 `lua` 模块, 并通过 `{{ }}` 将表达式结果嵌入正文. 灵活强大带来了极大的可能性.

5. **模板系统**. 用 `#:template` 声明带参数的可复用结构, 通过 `#:use` 传入实参展开生成. 适合将重复的格式(如 API 文档条目, 变更日志项)抽象为模板, 维护时只需修改一处定义.

## 安装  

从[Release](https://github.com/Water-Run/MarkColonDown/releases)下载(对应系统版本);  
运行`install.bat`(Windows)/`install.sh`(Linux), 依照指引进行.  

> 同样的, 卸载可以使用`uninstall.bat`/`uninstall.sh`进行  

安装完成后, 执行`mcd`指令(即`MarkColonDownCompiler`, `Mark:down`编译器), 验证安装:  

```cmd
Mark:down

v0.1.0, by WaterRun.

A powerful Markdown template engine, implemented as a strict superset of Markdown,
with "#:" line directives as the distinctive syntax, and embedded neolua.

Usage:
  mcd <command> [options]

Commands:
  init       Initialize a Mark:down project
             Generates Compile.md entry file and corresponding Log.md
             
  compile    Execute compilation
             Compiles Mark:down source files to Markdown output

Examples:
  mcd init                    # Initialize project in current directory
  mcd compile                 # Compile the project
  mcd init --entry ./docs     # Initialize in specified directory
  mcd compile --use Config.md # Compile with custom configuration file

GitHub: https://github.com/Water-Run/MarkColonDown
```

> 在Linux上, 另可使用`man`指令获取帮助  

## `Mark:down`的工作流简述  

执行`mcd init`命令会在目录下创建:  

- `Compile.mcd`, 默认的编译配置加载入口文件  
- `Log.mcd`, 默认的日志文件  
- `Global.mcd`, 默认的"全局"文件, 即, 自动在每个被处理的文件前`include`  
- `Source/`, 源码目录  
- `Target/`, 输出目录  

其中的每一项, 比如编译入口, 日志文件, 输入输出目录都是可自定义的. 不过, 我们就以全缺省状态进行说明.  
在运行`mcd compile`命令时, 编译器依次进行:  

1. 加载入口文件中的有关配置  
2. 扫描输入目录, 根据配置, 以及`.mcdignore`等文件, 列出待编译项目树  
3. 在输出目录复现结构树, 具体内容留空  
4. 依照树结构的顺序从上到下逐文件完成编译  

## 行指令速览表  

你可以阅读此表快速的过一遍`Mark:down`提供的行指令:  

| 语法结构            | 等效简化 | 说明                                                                                                                     |
|---------------------|----------|--------------------------------------------------------------------------------------------------------------------------|
| `#::`               | 无       | 显式声明这是一个 Mark:down 文件(无功能)；也常作为作为“注释行”使用（不会进入编译后的 Markdown）。                         |
| `#:1`~`#:6`         | 无       | x 级标题语法糖；编译为对应 Markdown 标题（`#`~`######`）。                                                               |
| `#:image`           | `#:!`    | 图片行；参数为图片路径，可选“(注解)”；编译为 Markdown 图片语法。                                                         |
| `#:link`            | `#:&`    | 链接行；参数为 URL，可选“(显示文本)”；编译为 Markdown 链接语法。                                                         |
| `#:table`           | `#:-`    | 表格块开始；到 `#:=` 结束；块内使用 CSV 语法（逗号分隔单元格，支持引号转义）。                                           |
| `#:ignore`          | `#:*`    | 编译时跳过整个文件（该文件不产生任何输出）。可以视为`#:if false`的语法糖。                                               |
| `#:skip`            | `#:~`    | 跳过 `skip` 与 `end`（或 `=`）之间的内容，不进入最终 Markdown。可以视为`#:if false`的语法糖。                            |
| `#:copy`            | `#:/`    | 编译时复制整个文件。可以视为`#:raw`的语法糖。                                                                            |
| `#:compile`         | `#:;`    | 编译指令。只能放在入口文件。                                                                                             |
| `#:echo`            | `#:>`    | 编译阶段打印信息（调试/日志用途），不影响最终输出内容。                                                                  |
| `#:end`             | `#:=`    | 通用终止符；结束 `skip/raw/code/if/while/for/template/table` 等块。                                                      |
| `#:include`         | `#:$`    | 导入并直接合并另一个文件（类似预处理 include）。                                                                         |
| `#:define`          | `#:%`    | 宏替换：编译期将匹配到的文本替换为目标文本（用于简易“全局替换/别名”）。                                                  |
| `#:raw`             | `#:^`    | 原样输出模式：`raw` 与 `end`（或 `=`）之间不解析 Mark:down 指令，按原文进入输出。                                        |
| `#:code`            | `#:?`    | 执行 MiniScript 代码；支持单行或代码块形式；代码本身不进入编译输出，但可设置变量/环境供后续 `{{}}` 与控制流使用。        |
| `#:if`              | 无       | 条件分支开始；后跟表达式；与 `elif/else/end`（或 `=`）配合使用。                                                         |
| `#:elif`            | 无       | 条件分支的“否则如果”。                                                                                                   |
| `#:else`            | 无       | 条件分支的“否则”。                                                                                                       |
| `#:while`           | 无       | while 循环；后跟条件表达式；以 `end`（或 `=`）结束。                                                                     |
| `#:for`             | 无       | for 循环；遵循 MiniScript 的 `for <var> in <sequence>` 风格表达式（可遍历 list/string/map 等）；以 `end`（或 `=`）结束。 |
| `#:template`        | `#:+`    | 声明模板：`TemplateName: param1, param2...`；块内通过参数名复用结构。                                                    |
| `#:use`             | `#:@`    | 调用模板：`TemplateName: arg1, arg2...`，按参数顺序替换展开生成输出。                                                    |
| `{{ ... }}`         | 无       | 内嵌输出：将表达式结果插入文本；`r{{}}` 禁用插值，保留字面量内容。                                                       |
| ` r`` ` 和 ` r``` ` | 无       | 原始代码块(不替换)。                                                                                                     |

> 在行指令`#:`之后,可以添加一个`<>`,表示满足对应flag时认可语句(否则视为语句不存在). 比如`#:<flag1>if`
>
> > 在`<>`内可以有一个或多个flag: `&`表示且, `|`表示或, `!`表示非, `()`表示优先级. 如`#:<flag1&(flag2|!flag3)>else`

## 关于代码内嵌  

`MiniScript`代码的内嵌可能是`Mark:down`最强大的功能, 条件判断也依赖于它. 同时, 它也很危险--`Mark:down`并不会判断你的执行的代码的安全性, 你需要自己负责.  
在之前的行指令速览表中, 我们可以看到代码块的形式形式内嵌, 使用`#:code`:  

```markcolondown
#:code print("line 1") -- 代码可以写在一行
#:code print("line 2")

#:code
-- 或者, 写在代码体内, 此时需要匹配通用中止(`#:end`/`#:=`), 且`#:code`之后不能有代码
hello = "Hello"
print(hello .. "Mark:down!")
#:=
```

行指令的代码输出将输出至编译器, 不直接影响文本的内容.  
使用`{{}}`的内嵌则将直接计算表达式, 并替换结果:  

```markcolondown
内嵌输出: {{ hello .. "Mark:down" }}
```

> 使用`#:raw`, `r{{}}`, 以及代码块中的` r`` `和多行的` r``` `避免`{{}}`内嵌  
